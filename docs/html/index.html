<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ME405 Mechatronics Romi: ME405 Mechatronics Romi</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ME405 Mechatronics Romi
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('index.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ME405 Mechatronics Romi </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1 class="doxsection"><a class="anchor" id="autotoc_md0"></a>
Project Overview</h1>
<p>The Romi project is part of California Polytechnic State University San Luis Obispo's Mechanical Engineering Course ME405 Mechatronics. The project entails the design and implementation of a robotic vehicle named Romi, which is a two-wheeled robot constructed from component sourced from Pololu Robotics and Electronics.</p>
<p>Romi‚Äôs objective is to traverse a predefined course with speed and precision, using integrated sensor feedback and actuator control. The course is defined by a series of waypoints, and Romi must navigate from one waypoint to the next following the class-defined rules. The robot's sensors include a line sensor made from several infrared (IR) sensors, bumps sensors to detect wall collisions, an inertial measurement unit (IMU) to measure orientation with respect to Earth's magnetic north, and quadrature encoders to measure the angular displacement of each wheel. Using information from these sensors, a State Observer is constructed to estimate the robot's current state, which importantly includes its current global position and orientation. Utilizing the Observer's estimations, the robot follows a path director and explores the course in order to reach the next waypoint.</p>
<div class="image">
<img src="Romi_isometric.jpeg" alt="" width="450"/>
<div class="caption">
Figure XXX: Romi Isometric</div></div>
<h1 class="doxsection"><a class="anchor" id="autotoc_md1"></a>
Final Romi Performance</h1>
<p> 
<div style="text-align:center;">
  <video width="700" controls>
    <source src="../assets/videos/best.mp4" type="video/mp4" />
    <source src="../assets/videos/best.mov" type="video/quicktime" />
    Your browser does not support the video tag. You can download the clip
    <a href="../assets/videos/best.mp4">here</a>.
  </video>
</div>
</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md2"></a>
Hardware</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md3"></a>
Chassis and Boards</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
Romi Chassis</h3>
<p>Romi's chassis is a component purchased from Pololu Robotics and Electronics. The chassis is a 2-wheeled robot with a center of gravity located at the center of the robot.</p>
<p>The chassis can be purchased at <a href="https://www.pololu.com/product/3509">https://www.pololu.com/product/3509</a> with additional components available at <a href="https://www.pololu.com/category/204/romi-chassis-components">https://www.pololu.com/category/204/romi-chassis-components</a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5"></a>
Power Distribution Board</h3>
<p>Romi's power distribution board is a component purchased from Pololu Robotics and Electronics. The board is used to power Romi's motors and other peripherals.</p>
<p>The power distribution board can be purchased at <a href="https://www.pololu.com/product/3543">https://www.pololu.com/product/3543</a>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6"></a>
Shoe of Brian</h3>
<p>Shoe of Brian was provided by ME405 Lab Instructor Charlie Refvem it is an open source board that can be used to interface iwth the Nucleo board. This shoe allows for uploading of code through the USB port. The Shoe of Brian also ensures that any USB devices connected are not powered by the Romi's battery which could damage the connected device.</p>
<p>A Shoe of Brian control board can be purchased at <a href="https://oshpark.com/shared_projects/e6X6OnYK">https://oshpark.com/shared_projects/e6X6OnYK</a> and <a href="https://spluttflob.github.io/ME405-Support/shoe_info.html">https://spluttflob.github.io/ME405-Support/shoe_info.html</a> details the steps to build one including additional components required.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7"></a>
Nucleo Board</h3>
<p>The Nucleo board was also provided by our ME405 Lab Instructor Charlie Refvem. The Shoe of Brian is built to be directly compatible with the Nucleo board.</p>
<p>We used the ST NUCLEO-L476RG, which integrates the STM32L476RG MCU plus an on-board ST-LINK/V2-1 debugger/programmer, user LEDs, and a user button. In code, hardware timers are configured in <span class="tt"><a class="el" href="main_8py.html" title="Entry point for Romi control firmware.">main.py</a></span> and consumed by <span class="tt"><a class="el" href="_motor_8py.html" title="Motor driver interface for DRV8838-style drivers on the Romi chassis.">Motor.py</a></span>/<span class="tt"><a class="el" href="_motor___controller_8py.html" title="Cooperative task that applies closed-loop control to a motor using encoder feedback.">Motor_Controller.py</a></span> for PWM drive and by <span class="tt"><a class="el" href="_encoder_8py.html" title="This file implements a quadrature encoder interface for the Romi robot.">Encoder.py</a></span> for quadrature capture. The I2C peripheral is used in <span class="tt"><a class="el" href="_i_m_u_8py.html" title="Driver for the BNO055 IMU on the Romi.">IMU.py</a></span>, ADC channels in <span class="tt"><a class="el" href="_battery_8py.html" title="Helper class for monitoring the battery voltage on the Romi robot.">Battery.py</a></span> and <span class="tt"><a class="el" href="_i_r___sensor_8py.html" title="Infrared reflectance sensor wrapper used by the line sensor array.">IR_Sensor.py</a></span>, UART in <span class="tt"><a class="el" href="_user___input_8py.html" title="Bluetooth/serial command handler for Romi.">User_Input.py</a></span>, and GPIO interrupts for bump sensors in <span class="tt"><a class="el" href="_path___director_8py.html" title="High-level state machine for directing the Romi through the course.">Path_Director.py</a></span>. The Shoe of Brian exposes the CN7/CN10 Morpho headers and Arduino headers so these peripherals can be wired cleanly to the Romi.</p>
<p>The Nucleo Board can be purchased directly from <a href="https://estore.st.com/en/products/evaluation-tools/product-evaluation-tools/mcu-mpu-eval-tools/stm32-mcu-mpu-eval-tools/stm32-nucleo-boards/nucleo-l476rg.html">https://estore.st.com/en/products/evaluation-tools/product-evaluation-tools/mcu-mpu-eval-tools/stm32-mcu-mpu-eval-tools/stm32-nucleo-boards/nucleo-l476rg.html</a> or from the same source as the datasheet <a href="https://os.mbed.com/platforms/ST-Nucleo-L476RG/">https://os.mbed.com/platforms/ST-Nucleo-L476RG/</a>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8"></a>
Motor</h2>
<p>Both wheels are driven by a Texas Instruments DRV8833 low-voltage H-bridge motor driver. Each motor shaft is equipped with an encoder (discussed below) and coupled to a gearbox that provides a 119.7576:1 reduction between the motor shaft and the wheel. In code, PWM drive and direction control are wrapped in <span class="tt"><a class="el" href="_motor_8py.html" title="Motor driver interface for DRV8838-style drivers on the Romi chassis.">Motor.py</a></span>, while <span class="tt"><a class="el" href="_motor___controller_8py.html" title="Cooperative task that applies closed-loop control to a motor using encoder feedback.">Motor_Controller.py</a></span> runs a closed-loop controller (<span class="tt"><a class="el" href="_closed___loop___control_8py.html" title="This file implements a generic closed-loop controller used for motor or mechanism speed/position cont...">Closed_Loop_Control.py</a></span>) using encoder feedback from <span class="tt"><a class="el" href="_encoder_8py.html" title="This file implements a quadrature encoder interface for the Romi robot.">Encoder.py</a></span> to set motor effort. Higher-level speed commands come from <span class="tt"><a class="el" href="_path___director_8py.html" title="High-level state machine for directing the Romi through the course.">Path_Director.py</a></span>, and hardware timers are configured in <span class="tt"><a class="el" href="main_8py.html" title="Entry point for Romi control firmware.">main.py</a></span>.</p>
<div class="image">
<img src="Motors.png" alt="" width="350"/>
<div class="caption">
Figure XXX: Texas Instruments DRV8833 Motor Drive with gearbox and Encoder</div></div>
<p>The motors follow the logic table below for its three input pins: nSLEEP, PH, and EN. nSLEEP acts as an on/off switch, PH acts as a direction switch, and EN acts as a drive/brake switch, which is manipulated via pulse width modulation (PWM).</p>
<p>The motor can be purchased directly from <a href="https://www.pololu.com/product/1520">https://www.pololu.com/product/1520</a>.</p>
<div class="image">
<img src="MotorLogicTable.png" alt="" width="900"/>
<div class="caption">
Figure XXX: DRV8833 Motor Logic Table</div></div>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9"></a>
Quadrature Incremental Encoder</h2>
<p>Each motor shaft is instrumented with a quadrature incremental encoder that measures the shaft‚Äôs angular displacement. These encoders employ two Hall-effect sensors that detect changes in the magnetic field produced by rotating permanent magnets. The corresponding magnet geometry and representative encoder waveform are shown below. The encoders used on the Romi utilize the same three-pole-pair magnet configuration illustrated.</p>
<div class="image">
<img src="Quad_Enc_3PP.png" alt="" width="450"/>
<div class="caption">
Figure XXX: Quadrature Output for Encoder with 3 Pole-Pair Magnets</div></div>
<p>By capturing the number of encoder ticks that occur across a measured time interval, the average angular velocity of each shaft can be calculated. Utilizing this information in conjunction with the motor's gear ratio and wheel radii, the linear velocity of each wheel can be calculated. These linear velocities are used to both close loop control Romi's behavior and to estimate its current state.</p>
<p>The encoder can be purchased directly from <a href="https://www.pololu.com/product/3542">https://www.pololu.com/product/3542</a>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10"></a>
Line Sensor</h2>
<p>In order to follow the 1/2 inch black lines on the course, Romi utilizes Pololu's line sensor composed of 13 infrared (IR) sensors. The line sensor array is aggregated in <span class="tt"><a class="el" href="_line___sensor_8py.html" title="Aggregates an array of IR sensors and computes line centroid position.">Line_Sensor.py</a></span>, which normalizes each IR reading (via <span class="tt"><a class="el" href="_i_r___sensor_8py.html" title="Infrared reflectance sensor wrapper used by the line sensor array.">IR_Sensor.py</a></span>) and computes the centroid of the detected line for feedback. The line-following closed-loop controller in <span class="tt"><a class="el" href="_closed___loop___control_8py.html" title="This file implements a generic closed-loop controller used for motor or mechanism speed/position cont...">Closed_Loop_Control.py</a></span> uses this centroid error in <span class="tt"><a class="el" href="_path___director_8py.html" title="High-level state machine for directing the Romi through the course.">Path_Director.py</a></span> to steer Romi along the course. Calibration (white/black) can be triggered through <span class="tt"><a class="el" href="_user___input_8py.html" title="Bluetooth/serial command handler for Romi.">User_Input.py</a></span> and is persisted by <span class="tt"><a class="el" href="_line___sensor_8py.html" title="Aggregates an array of IR sensors and computes line centroid position.">Line_Sensor.py</a></span> when flags are set from the task shares.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md11"></a>
Mounting</h3>
<p>The line sensor is mounted on the underside of the chassis using 3D-printed standoffs. The standoffs set the sensor height so the bump sensors contact obstacles first, protecting the board. Mounting holes were drilled out to fit the hardware available in the lab's donated parts bin. The SolidWorks part model for these standoffs lives in the <span class="tt">Mounting Bracket/</span> folder. Note that two of these standoffs are required to mount the line sensor.</p>
<div class="image">
<img src="linesensorbracket.png" alt="" width="350"/>
<div class="caption">
Figure XXX: Line sensor standoff bracket</div></div>
<h2 class="doxsection"><a class="anchor" id="autotoc_md12"></a>
IMU</h2>
<p>Romi uses an Adafruit BNO055 9-DOF absolute orientation sensor for heading and yaw-rate feedback. The breakout board includes an onboard microcontroller that fuses accelerometer, gyroscope, and magnetometer data to provide stable Euler angles without heavy processing on the Nucleo. The BNO055 breakout can be purchased at <a href="https://www.adafruit.com/product/2472">https://www.adafruit.com/product/2472</a>.</p>
<p>In code, the IMU is driven over I2C in <span class="tt"><a class="el" href="_i_m_u_8py.html" title="Driver for the BNO055 IMU on the Romi.">IMU.py</a></span>, which handles initialization, calibration loading/saving, and exposes heading/yaw-rate via <span class="tt">get_heading()</span> and <span class="tt">get_yaw_rate()</span>. The heading controller in <span class="tt"><a class="el" href="_closed___loop___control_8py.html" title="This file implements a generic closed-loop controller used for motor or mechanism speed/position cont...">Closed_Loop_Control.py</a></span> uses these readings inside <span class="tt"><a class="el" href="_path___director_8py.html" title="High-level state machine for directing the Romi through the course.">Path_Director.py</a></span> to align the robot for turns and point-to-point moves, and the <span class="tt"><a class="el" href="_observer_8py.html" title="State observer for the Romi.">Observer.py</a></span> task fuses IMU yaw data with encoder motion to estimate pose.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md13"></a>
Algorithms</h1>
<p>The following sections describe the algorithms and code architectures utilized to facilitate Romi's complex and intricate behaviors.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md14"></a>
Multitasking Architecture</h2>
<p>To achieve rapid and precise motion control, Romi requires a robust and efficient software architecture capable of executing a wide range of complex behaviors within short time intervals. Romi utilizes a priority-based, round-robin multitasking framework that enables effective multitasking on its single-core microprocessor. The architecture is created in <code><a class="el" href="cotask_8py.html" title="This file contains classes to run cooperatively scheduled tasks in a multitasking system.">cotask.py</a></code> and instantiated in <code><a class="el" href="main_8py.html" title="Entry point for Romi control firmware.">main.py</a></code>.</p>
<p>Within this framework, the system is organized into discrete tasks (<code><a class="el" href="classcotask_1_1_task.html" title="Implements multitasking with scheduling and some performance logging.">cotask.Task</a></code>), each characterized by a specified <code>period</code> and <code>priority</code>. The <code>period</code> defines the desired interval, in milliseconds, between successive executions of a task‚Äôs <code>run()</code> method. In practice, certain computationally intensive algorithms may prevent tasks from executing exactly at their designated periods. Under such circumstances, a task is executed as soon as it becomes the highest-priority task awaiting processor time. Consequently, higher-priority tasks always preempt lower-priority tasks when multiple tasks are ready to run simultaneously. If two tasks of equal priority are queued to run, then, in accordance with round-robin scheduling, the task that has been awaiting execution for the longer duration is dispatched first.</p>
<p>As mentioned above, each task has a <code>run()</code> method that is responsible for performing its specific behavior. If it is desired to communicate information between tasks, a task can use <code><a class="el" href="task__share_8py.html" title="This file contains classes which allow tasks to share data without the risk of data corruption by int...">task_share.py</a>'s</code> <code><a class="el" href="classtask__share_1_1_share.html" title="An item which holds data to be shared between tasks.">task_share.Share</a></code> or <code><a class="el" href="classtask__share_1_1_queue.html" title="A queue which is used to transfer data from one task to another.">task_share.Queue</a></code> objects. These objects are used to transfer data between tasks with protection against data corruption by interrupts, among other features.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md15"></a>
Task Diagram</h3>
<p>Below is a diagram of each <code><a class="el" href="classcotask_1_1_task.html" title="Implements multitasking with scheduling and some performance logging.">cotask.Task</a></code> in Romi's system. The <code>period</code> and <code>priority</code> of each task is specified, as well as each <code><a class="el" href="classtask__share_1_1_share.html" title="An item which holds data to be shared between tasks.">task_share.Share</a></code> and <code><a class="el" href="classtask__share_1_1_queue.html" title="A queue which is used to transfer data from one task to another.">task_share.Queue</a></code> that it uses.</p>
<div class="image">
<img src="Task_Diagram.png" alt="" width="800"/>
<div class="caption">
Figure XXX: Romi's Task Diagram</div></div>
<h3 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
User Input</h3>
<p>The user input (<code><a class="el" href="_user___input_8py.html" title="Bluetooth/serial command handler for Romi.">User_Input.py</a></code>) task is responsible for receiving commands from the user and actualizing them into physical outputs. User input processes the single-character commands from both the USB and Bluetooth interfaces into values that are placed in shares. Those shares then trigger other tasks to perform their respective functions.</p>
<div class="image">
<img src="User_Input.png" alt="" width="500"/>
<div class="caption">
Figure XXX: User Input Task Logic Diagram</div></div>
<h2 class="doxsection"><a class="anchor" id="autotoc_md17"></a>
Path Director</h2>
<p>With the control tools described above, the remaining requirement for Romi is a structured framework to govern its overall motion. The path director (<code><a class="el" href="_path___director_8py.html" title="High-level state machine for directing the Romi through the course.">Path_Director.py</a></code>) fulfills this role by planning and coordinating Romi‚Äôs actions throughout the course. Implemented as a state machine, each state corresponds to a distinct behavioral mode, while additional function states provide generalized control capabilities that accept variable inputs. This design enables compact, modular code and facilitates targeted testing of individual behaviors without restarting an entire course run. As the top-level supervisory controller, the path director manages all aspects of Romi‚Äôs navigation and ensures coherent execution of its course-traversal strategy.</p>
<div class="image">
<img src="Path_Director.png" alt="" width="500"/>
<div class="caption">
Figure XXX: Path Director Task Logic Diagram</div></div>
<h3 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
Motor Controller</h3>
<p>The motor controller (<code><a class="el" href="_motor___controller_8py.html" title="Cooperative task that applies closed-loop control to a motor using encoder feedback.">Motor_Controller.py</a></code>) task is responsible for controlling Romi's motors. The motor controller task has the responsibility of determining what the motor should be doing based off the shares and queues passed into it. Every time it is ran, it runs one iteration of the closed loop control law and then updates the effort requested of the motors.</p>
<div class="image">
<img src="Motor_Controller.png" alt="" width="500"/>
<div class="caption">
Figure XXX: Motor Controller Task Logic Diagram</div></div>
<h2 class="doxsection"><a class="anchor" id="autotoc_md19"></a>
State Observer</h2>
<p>Using the data from Romi's sensors, the state observer (<code><a class="el" href="_observer_8py.html" title="State observer for the Romi.">Observer.py</a></code>) estimates Romi‚Äôs current state such that behavioral decisions can be made based on Romi‚Äôs current position and orientation. To obtain state estimation, two approaches were considered: the fourth-order Runge-Kutta solver or discretizing Romi‚Äôs state space. The Runge-Kutta method was not chosen since it was determined that the frequency at which it would have to run would impose too significant of a computational load on Romi's multitasking system. Instead, Romi‚Äôs state space was discretized using control theory techniques and Matlab‚Äôs <code>c2d()</code> functionality. Further elaboration on the discretization process can be found in the Analysis section.</p>
<div class="image">
<img src="Observer.png" alt="" width="500"/>
<div class="caption">
Figure XXX: Observer Task Logic Diagram</div></div>
<h3 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
Garbage Collector</h3>
<p>The garbage collector (<code><a class="el" href="_garbage___collector_8py.html" title="Cooperative task that periodically triggers MicroPython garbage collection to reduce fragmentation du...">Garbage_Collector.py</a></code>) task is responsible for managing Romi's memory. Upon each iteration of the garbage collector, the task garbage collects and removes any memory that is no longer in use.</p>
<div class="image">
<img src="Garbage_Collector.png" alt="" width="500"/>
<div class="caption">
Figure XXX: Garbage Collector Task Logic Diagram</div></div>
<h2 class="doxsection"><a class="anchor" id="autotoc_md21"></a>
Closed Loop Control</h2>
<p>Romi‚Äôs motion accuracy relies heavily on the versatile and robust closed loop controller implemented in <code><a class="el" href="_closed___loop___control_8py.html" title="This file implements a generic closed-loop controller used for motor or mechanism speed/position cont...">Closed_Loop_Control.py</a></code>. This controller provides a unified framework for regulating motor speed or heading and supports a wide range of classical control features, making it adaptable to all dynamic behaviors required by the robot.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
PID Control:</h3>
<p>At its core, the controller computes actuating commands by continually comparing some reference input, \( r \), to the measured output, \( \hat{x} \), provided by any sensor object provided. Each sensor supplies both a measurement and a corresponding time increment ( \( dt \)), allowing the controller to compute proportional, integral, and derivative error terms. These components form the basis of standard P, PI, PD, and PID control. In addition to these standard terms, the controller incorporates several enhancements that improve reliability under real-world operating conditions:</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md23"></a>
Feed-Forward Control:</h3>
<p>A feed-forward term scales the commanded reference input directly, improving response time and reducing the burden on feedback terms, particularly during rapid accelerations or when executing pre-planned maneuvers.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md24"></a>
Anti-Windup Compensation:</h3>
<p>When actuator commands saturate‚Äîsuch as when the controller demands more torque than the motors can provide‚Äîthe integral term can accumulate excessively and degrade stability. The controller mitigates this through an anti-windup mechanism that automatically adjusts the integral term whenever saturation occurs, preserving steady-state accuracy without overshoot.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md25"></a>
Battery Droop Compensation:</h3>
<p>Battery voltage naturally decreases during operation, affecting motor torque and responsiveness. When provided with a battery-monitoring object, the controller dynamically adjusts its gains to maintain consistent performance despite changes in supply voltage.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md26"></a>
Soft-Start Reference Ramping:</h3>
<p>To prevent sudden jerks or torque spikes, the controller gradually ramps its internal reference toward the commanded setpoint. This soft-start feature improves mechanical safety, reduces wheel slip, and enhances tracking smoothness during abrupt transitions.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
Output Saturation:</h3>
<p>After computing all relevant components, the controller generates a preliminary actuator command ( \( a \)), applies the appropriate saturation constraints, and thereby produces the final output ( \( a^* \)). This finalized command is then returned and utilized within one of three closed-loop control modalities: velocity CLC, line centroid CLC, or heading CLC.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md28"></a>
Velocity CLC:</h3>
<p>As per the code structure, each <code><a class="el" href="_motor_8py.html" title="Motor driver interface for DRV8838-style drivers on the Romi chassis.">Motor.py</a></code> is handled by a <code><a class="el" href="_motor___controller_8py.html" title="Cooperative task that applies closed-loop control to a motor using encoder feedback.">Motor_Controller.py</a></code> task. Whenever the motor controller requests a motor to move at a given speed, the desired velocity is passed to the velocity CLC. Upon the scheduled execution of the Motor Controller task, the velocity CLC computes the new motor effort to be applied such that the desired velocity is reached/maintained.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md29"></a>
Line Centroid CLC:</h3>
<p>To enable reliable line following, Romi determines the centroid of the detected black region using the line sensor module (<code><a class="el" href="_line___sensor_8py.html" title="Aggregates an array of IR sensors and computes line centroid position.">Line_Sensor.py</a></code>). Because the control objective is to maintain Romi‚Äôs geometric center directly over the course line, the closed-loop controller‚Äôs reference value is fixed at zero. By supplying the measured centroid to \( \hat{x} \), the line-centroid CLC computes the appropriate yaw rate required to realign the robot with the line. This commanded yaw rate is subsequently translated into differential motor actuation, producing the necessary increase and decrease in wheel velocities to achieve accurate line tracking.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md30"></a>
Heading CLC:</h3>
<p>The heading CLC is designed for use in conjunction with an IMU object (<code><a class="el" href="_i_m_u_8py.html" title="Driver for the BNO055 IMU on the Romi.">IMU.py</a></code>). When Romi is required to navigate toward a target that is not located on the black course lines, it must first orient itself toward the desired heading and subsequently maintain that orientation as it moves and undergoes natural drift. The heading CLC computes the yaw rate necessary for Romi to achieve and sustain the specified heading. This commanded yaw rate is then converted into differential motor actuation, providing the appropriate adjustments in wheel velocities to ensure stable and accurate heading control throughout the maneuver.</p>
<div class="image">
<img src="Closed_Loop_Control.png" alt="" width="500"/>
<div class="caption">
Figure XXX: Closed Loop Control Diagram</div></div>
<h1 class="doxsection"><a class="anchor" id="autotoc_md31"></a>
Key Analyses and Validations</h1>
<p>The following sections provide some of the key analyses of Romi‚Äôs dynamics and performance characteristics. These analyses are intended to provide a comprehensive understanding of Romi‚Äôs behavior and to facilitate the development of future improvements.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md32"></a>
Closed Loop Control Gain Tuning</h2>
<p>The closed-loop controller for Romi‚Äôs drive motors was developed using an incremental gain-tuning process in which controller complexity was expanded stepwise and evaluated experimentally. The tuning sequence progressed through proportional (P), proportional‚Äìintegral (PI), and proportional‚Äìintegral‚Äìderivative (PID) structures, followed by the integration of feed-forward compensation and battery-voltage droop correction. All controller gains were adjustable in real time through the host computer interface, and all experimental plots were generated automatically. The following discussion summarizes the left-wheel results, with qualitative agreement across both wheels.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md33"></a>
P Controller</h3>
<p>Initial testing began with a purely proportional controller. With a relatively high proportional gain, Romi exhibited pronounced oscillatory ‚Äújittering,‚Äù characterized by rapid forward‚Äìbackward motion about the reference value.</p>
<div class="image">
<img src="P_jitter.png" alt="" width="1000"/>
<div class="caption">
Figure XXX: Proportional Controller ‚Äì Initial High Gain Response</div></div>
<p>The oscillation resulted from overly aggressive corrective action, causing repeated overshoot of the target velocity. The proportional gain was iteratively reduced until the oscillations were eliminated.</p>
<div class="image">
<img src="P_good.png" alt="" width="1000"/>
<div class="caption">
Figure XXX: Proportional Controller ‚Äì Tuned Gain Response</div></div>
<h3 class="doxsection"><a class="anchor" id="autotoc_md34"></a>
PI Controller</h3>
<p>After stabilizing the proportional controller, an integral term was introduced to eliminate steady-state error. The initial integral gain produced a stable response with no overshoot‚Äîan indication that the selected gain was likely too small to minimize convergence time.</p>
<div class="image">
<img src="PI_under.png" alt="" width="1000"/>
<div class="caption">
Figure XXX: PI Controller ‚Äì Initial Small Integral Gain</div></div>
<p>The integral gain was gradually increased to identify an upper bound beyond which overshoot became unacceptable.</p>
<div class="image">
<img src="PI_over.png" alt="" width="1000"/>
<div class="caption">
Figure XXX: PI Controller ‚Äì Excessive Integral Gain</div></div>
<p>A gain between these two extremes was selected through iterative testing, yielding minimal overshoot and improved settling behavior.</p>
<div class="image">
<img src="PI_good.png" alt="" width="1000"/>
<div class="caption">
Figure XXX: PI Controller ‚Äì Tuned Integral Gain</div></div>
<h3 class="doxsection"><a class="anchor" id="autotoc_md35"></a>
PID Controller</h3>
<p>With the PI controller tuned, a derivative term was introduced. The initial derivative gain caused unstable, jitter-like oscillations similar to those observed with an overly large proportional gain.</p>
<div class="image">
<img src="PID_initial.png" alt="" width="1000"/>
<div class="caption">
Figure XXX: PID Controller ‚Äì Initial Derivative Gain</div></div>
<p>Significant reductions in derivative gain were attempted:</p>
<div class="image">
<img src="PID_reduced1.png" alt="" width="1000"/>
<div class="caption">
Figure XXX: PID Controller ‚Äì Reduced Derivative Gain Attempt 1</div></div>
 <div class="image">
<img src="PID_reduced2.png" alt="" width="1000"/>
<div class="caption">
Figure XXX: PID Controller ‚Äì Reduced Derivative Gain Attempt 2</div></div>
<p>However, due to the presence of high-frequency noise in Romi‚Äôs sensor data, derivative action consistently amplified this noise and degraded performance. Consequently, derivative control was deemed unsuitable and removed from all further controller configurations.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md36"></a>
PI Controller with Feed-Forward Compensation</h3>
<p>Since PID control was abandoned, the next enhancement involved adding a feed-forward term to the existing PI structure. Unlike earlier gains, the feed-forward gain K<sub>ff</sub> was computed analytically. Steady-state velocity data was used to generate linear curve fits of wheel velocity versus PWM input.</p>
<div class="image">
<img src="SSvsPWM.png" alt="" width="500"/>
<div class="caption">
Figure XXX: Steady-State Wheel Velocities vs. PWM Input</div></div>
<p>The slopes of these fits yielded steady-state gains, and their inverses provided the appropriate feed-forward gains for each motor. The x-intercepts of the fits were used to estimate the minimum PWM values needed to initiate motion,PWM<sub>start</sub>, producing the feed-forward relations:</p>
<p class="formulaDsp">
\[PWM = K_{ff}*v + PWM_{start}
\]
</p>
<p>The feed-forward controller was tested with PI control:</p>
<div class="image">
<img src="PI_KFF.png" alt="" width="1000"/>
<div class="caption">
Figure XXX: PI + Feed-Forward Response</div></div>
<p>Performance with feed-forward alone was notably accurate and feed forward tuning was concluded</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md37"></a>
PI + Feed-Forward + Battery Droop Compensation</h3>
<p>Lastly, to improve robustness against battery discharge, a voltage droop compensation term was incorporated. As battery voltage decreases, motor steady-state gains diminish, causing unintended reductions in wheel velocity. To counteract this, the commanded PWM was scaled according to:</p>
<p class="formulaDsp">
\[PWM_{\text{scaled}} = PWM \left(\frac{V_{\text{full}}}{V_{\text{measured}}}\right)
\]
</p>
<p>This battery-droop compensation has minimal influence during most of Romi‚Äôs operation, as the supply voltage remains relatively stable throughout the majority of the battery‚Äôs useful life. However, as the battery approaches depletion, the scaling factor becomes increasingly significant. Experimental observations indicate that the rate at which Romi attains its commanded velocity remains effectively unchanged despite substantial voltage droop, providing qualitative confirmation of the compensation scheme‚Äôs effectiveness.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md38"></a>
Romi Dynamics</h2>
<p>To adequately understand how Romi would behave, a dynamic analysis was performed. To define variables, the space in which Romi exists in was defined as seen below</p>
<div class="image">
<img src="Romi_body.jpg" alt="" width="500"/>
<div class="caption">
Figure XXX: Coordinate System Definition for Romi Dynamics</div></div>
<div class="image">
<img src="Romi_global.jpg" alt="" width="500"/>
<div class="caption">
Figure XXX: Global Coordinate System</div></div>
<p>The state of Romi was determined to be constituted of of six variables: global X position, global Y position, global heading, centroid displacement (like an odometer), angular velocity of the left wheel, and angular velocity of the right wheel. Using this state breakdown, Romi‚Äôs dynamics were analyzed using the following equations:</p>
<div class="image">
<img src="State_input_output.jpg" alt="" width="500"/>
<div class="caption">
Figure XXX: Romi State Space, Input, and Output Matrices</div></div>
<div class="image">
<img src="xdot.png" alt="" width="500"/>
<div class="caption">
Figure XXX: State Derivative Equations</div></div>
<div class="image">
<img src="y.png" alt="" width="500"/>
<div class="caption">
Figure XXX: Output Equations</div></div>
<h2 class="doxsection"><a class="anchor" id="autotoc_md39"></a>
State Observer</h2>
<p>To implement Romi‚Äôs observer in discrete time, the continuous-time system model was first defined using the continuous matrices ùê¥, ùêµ, ùê∂, and ùê∑ obtained from the dynamics above. These matrices depend on measured physical parameters such as wheel radius, ùëü, and track width, <code>w</code>. Although nominal values were initially used, subsequent measurements indicated small deviations; therefore, an updated wheel radius value was substituted into all system equations to improve model accuracy.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md40"></a>
Selecting Observer Dynamics and Constructing the Continuous Model</h3>
<p>Because the observer is a fourth-order system, four desired eigenvalues were required for the observer error dynamics. Two eigenvalues were selected as a complex conjugate pair corresponding to a second-order system designed to achieve a target overshoot percentage and settling time. The remaining two eigenvalues were chosen as real poles placed far to the left in the complex plane to ensure rapid decay of the associated modes. This yields a dominant second-order estimation response while maintaining full-order stability.</p>
<p>Using the classical second-order relationships:</p>
<p class="formulaDsp">
\[%OS = e^{\left( -\frac{\zeta\pi}{\sqrt{1-\zeta^2}} \right)}, \qquad
t_s \approx \frac{3}{\zeta\omega_n},
\]
</p>
<p>the desired damping ratio, ùúÅ, and natural frequency, ùúî<sub>n</sub>, were computed from the specified overshoot and settling-time requirements. Substituting ùúÅ and ùúî<sub>n</sub> into the second-order characteristic equation,</p>
<p class="formulaDsp">
\[s^2 + 2\zeta\omega_n s + \omega_n^2 = 0,
\]
</p>
<p>produced the first two poles for the observer. Two additional poles were then selected at large negative real values (e.g.,</p>
<p>ùë† = ‚àí 25 s=‚àí25 and ùë† = ‚àí 30 s=‚àí30), forming the complete fourth-order characteristic polynomial:</p>
<p class="formulaDsp">
\[(s - p_1)(s - p_2)(s - p_3)(s - p_4) = 0. \tag{1}
\]
</p>
<p>The roots of Equation (1) served as the desired observer poles.</p>
<p>Using MATLAB‚Äôs <code>place()</code> function, the continuous-time observer gain matrix, ùêø, was computed from the matrices <code>A</code> and <code>C</code> and the pole locations defined above.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md41"></a>
Computing A<sub>d</sub> and B<sub>d</sub> from the Continuous Model</h3>
<p>With the continuous-time system matrices established, the next step was to obtain the discrete-time equivalents required for implementation in Romi‚Äôs observer task. The discrete model has the form</p>
<p class="formulaDsp">
\[x[k+1] = A_d x[k] + B_d u[k],
\]
</p>
<p>where the sampling period, Œît, must match the execution period of the observer task in the cooperative scheduler.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md42"></a>
Step 1 ‚Äî Forming the Continuous Augmented System</h4>
<p>Using standard continuous-to-discrete relationships, the following continuous expressions were first evaluated:</p>
<p class="formulaDsp">
\[A_c = A - LC,\qquad
B_c = \begin{bmatrix} B &amp; L \end{bmatrix},
\]
</p>
<p>which correspond to the continuous-time error-dynamics model used for observer prediction and correction.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md43"></a>
Step 2 ‚Äî Using MATLAB‚Äôs c2d Function</h4>
<p>These continuous matrices were discretized using MATLAB‚Äôs zero-order hold conversion:</p>
<p class="formulaDsp">
\[(A_d,, B_d) = \mathrm{c2d}(A_c,, B_c,, \Delta t).
\]
</p>
<p>MATLAB returns the discrete-time matrices: A<sub>d</sub>, the discrete-time state-transition matrix, and B<sub>d</sub>, the discrete-time input matrix corresponding to the augmented input vector</p>
<p>These matrices were then exported and embedded into the Observer class to perform the real-time update:</p>
<p class="formulaDsp">
\[\hat{x}[k+1] = A_d \hat{x}[k] + B_d u[k].
\]
</p>
<p>The resulting discrete model matches the execution rate of the observer task and ensures that Romi‚Äôs estimated pose evolves consistently with the continuous-time dynamics.</p>
<div class="image">
<img src="obs_xuy.png" alt="" width="500"/>
<div class="caption">
Figure XXX: Observer State Space, Input, and Output Matrices</div></div>
<h1 class="doxsection"><a class="anchor" id="autotoc_md44"></a>
Hardware Setup</h1>
<p>If any efforts are made to emulate the Romi setup, the following wiring diagram should be used:</p>
<div class="image">
<img src="wiring_cn7.png" alt="" width="1000"/>
<div class="caption">
Figure XXX: Wiring Diagram for Romi's C7 Morpho Headers</div></div>
<div class="image">
<img src="wiring_cn10.png" alt="" width="1000"/>
<div class="caption">
Figure XXX: Wiring Diagram for Romi's C10 Morpho Headers</div></div>
 </div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
</div><!-- doc-content -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
